---
layout: post
title: Basic image analysis in Python
date: 2010-06-08 09:12:50.000000000 -07:00
type: post
published: true
status: publish
categories:
- computing
- experiments
- physics
- python
- teaching
tags:
- image analysis
- kirlian photography
- laplace
- python
- scipy
meta:
  _edit_last: '506905'
  _wp_old_slug: ''
  twitter_cards_summary_img_size: a:7:{i:0;i:287;i:1;i:285;i:2;i:2;i:3;s:24:"width="287"
    height="285"";s:4:"bits";i:8;s:8:"channels";i:3;s:4:"mime";s:10:"image/jpeg";}
author:
  login: adawes
  email: dawes@pacificu.edu
  display_name: AMCDawes
  first_name: ''
  last_name: ''
---
<p>[caption id="attachment_336" align="alignright" width="200" caption="Photo Credits: Harold Vanta"]<a href="http://dawes.files.wordpress.com/2010/06/jefferson_small_crop.jpg"><img src="{{ site.baseurl }}/assets/jefferson_small_crop.jpg" alt="" title="Kirlian Photograph Coin" width="200" class="size-full wp-image-336" /></a>[/caption]I always like to have a response ready for those times that people inevitably ask "why do you use Python in your research, don't you know c or Fortran?" I always like that question. "Yes, I know c and Fortran, and I know how painful and slow it can be to code and debug c and Fortran." Another prime example came to life over this past semester. I was working with a student on a senior capstone project and he was looking at images of the corona discharge around various metal objects. We wanted to analyze the images and map the brightness to the relevant physics (i.e., the electric field surrounding the object).<br />
<!--more--></p>
<p>Our analysis task was to import images (JPG format), extract numerical data (pixel brightness), and compare to various theories. While I'm sure there are straightforward ways to do this in other languages, I found Python had more than enough to offer in terms of possible solutions. One additional requirement was that we wanted to average many slices of the image in order to decrease the sensitivity to localized variations. The final solution was to import the image using tools provided by <a title="Scientific Python" href="http://www.scipy.org">Scipy</a>. This also allowed us to use standard image processing functions to rotate the image and average many cross sections. Because the object (a nickel) has rotational symmetry, we took 36 slices (each 10 degrees from the previous) and averaged them. This gives a good picture of the radial dependence of the brightness. Plotting and fitting were straightforward using other Scipy routines or your favorite 2D plotting software (mine is <a href="http://www.visualdatatools.com/DataGraph/index.html">DataGraph</a>).</p>
<p>Writing and debugging the code took about an hour and plotting/analyzing took about another hour. Two hours start to finish!</p>
<p>We quickly realized that we don't have an analytic theory to compare to so we discussed various numerical models and decided to implement a relaxation method to solve the Laplace equation in 3D for a reasonable set of boundary conditions. This code took about 1.5 hours and depending on the mesh density, runs in about 3 minutes. Best of all, we get very interesting qualitative agreement. All this for about 4 hours at the computer. Not too shabby.</p>
<p>For what it's worth, the code is attached below. The relevant functions are scipy.misc.imread, pylab.imshow, pylab.semilogy, and scipy.sum. These import an image, show an image, plot on semilog axis, and sum an array along one axis. The code comments should help illustrate why each is used.</p>
<p>Image analysis:</p>
<p>[sourcecode]<br />
from pylab import imshow, figure, zeros, plot<br />
from scipy.misc import imread<br />
from scipy.ndimage.interpolation import rotate<br />
from numpy import savetxt</p>
<p>a = imread(&quot;Jefferson.JPG&quot;,flatten=1)<br />
# imshow(a)</p>
<p>center = [1930,1289] # define the center of the image (for cropping)<br />
width = 1000 # choose a radius for the cropped image</p>
<p>crop = a[center[0]-width:center[0]+width,center[1]-width:center[1]+width]<br />
# imshow(crop)</p>
<p>stack = zeros((2000,10)) # create an array to save the slices<br />
total = stack[:,0] # create an array to save the average slice</p>
<p>for i in range(10): # take ten slices<br />
	stack[:,i] = rotate(crop,i*36,reshape=False)[1000,:]<br />
	total += stack[:,i]</p>
<p>plot(total) # plot the data<br />
savetxt(&quot;Jefferson-v2.dat&quot;, total) # save the data to a file<br />
[/sourcecode]</p>
<p>Relaxation method:</p>
<p>[sourcecode]<br />
from scipy.misc import imread<br />
from pylab import gray, imshow, plot, show, semilogy<br />
from scipy import zeros, sum</p>
<p>image = imread(&quot;circle.png&quot;,flatten=True)<br />
image = -image + 255 # rescale so background is zero</p>
<p>sizex,sizey = image.shape<br />
depth = 15</p>
<p>mesh = zeros((sizex,sizey,depth))</p>
<p>mesh[:,:,0] = image<br />
mesh[:,:,1] = image<br />
mesh[:,:,2] = image<br />
mesh[:,:,3] = image<br />
mesh[:,:,4] = image</p>
<p>runs = 500<br />
# iterate over the whole array setting each point to be<br />
# the average of the neighbors<br />
for round in range(runs):<br />
     print &quot;Run number: &quot;, round<br />
     for i in range(sizex-2):<br />
          for j in range(sizey-2):<br />
               for k in range(depth-2):<br />
                    mesh[i+1,j+1,k+1] = 0.166 * (mesh[i+1,j+1,k] + mesh[i+1,j+1,k+2] + mesh[i+1,j,k+1] + mesh[i+1,j+2,k+1] + mesh[i,j+1,k+1] + mesh[i+2,j+1,k+1])</p>
<p>total = sum(mesh, axis=2) # Sum the potential through the whole region. This was to see if the light generated is proportional to the potential. It is more likely that the light is proportional to the field strength so more calculation will be required.<br />
semilogy(total[:,sizex/2]) # plot a slice through the center of the region<br />
[/sourcecode]</p>
<p>I should point out that one interesting feature of this code is that is uses an image to provide the initial conditions for the Laplace solver. This means that the code could be easily adapted to a wide variety of situations and you could quickly explore all sorts of funky shapes.</p>
<p>The top five slices are set to have the potential given in a grayscale image. I just created a black circle on a white background in Inkscape and exported it to PNG. The code inverts this image in order to set the voltage to 255 in the center and 0 on the outside. Then there is a little trick to zero (ground) the areas outside the circle. From there, it's just a for loop that carries out the relaxation method: set each point to the average of the neighbors.</p>
<p>This project isn't necessarily polished, but I wanted to share the code in case anyone is looking for something like this. If you have to extract some data from an image, python is a great place to start.</p>
