---
layout: post
title: Scientific Python
date: 2011-01-02 11:48:02.000000000 -08:00
type: post
published: true
status: publish
categories:
- computing
- experiments
- open source software
- physics
- python
- try this at home
tags:
- enthought
- numpy
- python
- scipy
meta:
  _edit_last: '506905'
author:
  login: adawes
  email: dawes@pacificu.edu
  display_name: AMCDawes
  first_name: ''
  last_name: ''
---
<p><a href="http://dawes.files.wordpress.com/2010/07/screen-shot-2010-07-27-at-7-18-00-am.png"><img class="alignleft size-full wp-image-356" title="Scipy" src="{{ site.baseurl }}/assets/screen-shot-2010-07-27-at-7-18-00-am.png" alt="" width="59" height="56" /></a>I have been using python more and more in my scientific work. This has been enabled by several excellent resources. The most important resource is the <a href="http://www.enthought.com">Enthought Python Distribution</a> (EPD). The EPD makes it trivially easy to have a complete python installation that includes many scientific packages. Best of all, the EPD is available for free under an Academic license. All software included in the EPD is open-source so it is straightforward to install an equivalent set of packages; the only difference is convenience. Enthought also offers many tutorials, webinars, and other support resources for scientific python.</p>
<p>Here, I have put together some of my favorite resources, along with a brief presentation that illustrates the power of SciPy/Numpy through several examples based on my own various projects.</p>
<p><!--more--></p>
<p>These resources are also available at my <a href="http://newton.ns.pacificu.edu/~dawes/python">python resources page</a>. The examples that can be found at the end of this post and in my presentation:</p>
<ul>
<li>import data and plot two columns as x and y</li>
<li>fit data with an arbitrary function</li>
<li>extract relative intensity data from an image</li>
<li>propagate uncertainties in formula evaluation</li>
</ul>
<p>The last example requires software that is not available in the EPD, but it is very easy to install. The <a href="http://pypi.python.org/pypi/uncertainties/">python uncertainties</a> package is a great tool for propagating error when evaluating formulas using numbers with uncertainty. There are formulas for this and I'm sure some calculators can do it, but this package has a great interface and makes error propagation something to stop fearing.</p>
<p>I have helped several students get started using python (SciPy in particular) and each of them have commented positively on how easy it is to learn and to keep using. I'll have a few python projects that I will post here as they mature. In the meantime, enjoy these links and happy coding.</p>
<h3>Import data and plot</h3>
<p>[sourcecode language="python"]<br />
from scipy import loadtxt<br />
from pylab import figure, plot, title, xlabel, ylabel, show</p>
<p>data = loadtxt(&quot;TEK0006.CSV&quot;, delimiter=&quot;,&quot;, usecols=(3,4))</p>
<p>time = data[:,0] # 0th column is time data<br />
voltage = data[:,1] # 1st column is voltage data</p>
<p>transmission = voltage/max(voltage)</p>
<p>fig = figure()</p>
<p>plot(time,transmission)</p>
<p>title(&quot;Cold Rb-87 Spectrum, F=2-&gt;F'&quot;)<br />
xlabel(&quot;Time (s)&quot;)<br />
ylabel(&quot;Transmission (Arb. Units)&quot;)<br />
show()<br />
 [/sourcecode]</p>
<p>This code loads columns 3 and 4 (zero indexed) from a csv file. In this case it is a file saved by a Tektronix scope (TEK0006.CSV). The time and voltage data are named to make calculations more transparent. Finally, the voltage is scaled to its own max. In this case, the signal is a spectroscopic transmission so to convert to transmission, we just scale to the max and call that 1 (full transmission). Finally, we plot with some labels and a title.</p>
<h3>Fit with arbitrary function</h3>
<p>[sourcecode language="python"]<br />
from numpy import linspace, exp, random<br />
from pylab import plot, show<br />
from scipy.optimize import curve_fit</p>
<p>def func(x, a, b, c):<br />
	return a * exp(-b*x) + c</p>
<p>x = linspace(0.0, 4.0, 50) # 50 points from 0 to 4)<br />
y = func(x, 2.2, 1.7, -0.5)<br />
yn = y + 0.2*random.normal(size=len(x))</p>
<p>[a, b, c], covar = curve_fit(func, x, yn)</p>
<p>print &quot;a = &quot;, a, &quot; var_a = &quot;, covar[0,0]<br />
print &quot;b = &quot;, b, &quot; var_b = &quot;, covar[1,1]<br />
print &quot;c = &quot;, c, &quot; var_c = &quot;, covar[2,2]<br />
plot(x, yn)<br />
plot(x, func(x, *[a,b,c]), '-k')<br />
show()<br />
[/sourcecode]</p>
<p>First, define a function with some variables (a, b, c). As a demo, we have to generate some data, so we take the function and add some random noise. In an experimental situation, you could import data as in the prior example, and play with fitting against the actual data. Finally, output the covar elements from curve_fit to find the uncertainty in the three fit parameters. Students love this since usually the do curve fitting in excel and then complain that they don't know the uncertainty in the fit. "Use better tools" I say, and here is one that's easy to use.</p>
<h3>Extract image intensity</h3>
<p>[sourcecode language="python"]<br />
from pylab import imshow, figure, zeros, plot<br />
from scipy.misc import imread<br />
from scipy.ndimage.interpolation import rotate<br />
from numpy import savetxt</p>
<p>a = imread(&quot;Jefferson.JPG&quot;,flatten=1)<br />
# imshow(a)</p>
<p>center = [1930,1289] # define the center of the image (for cropping)<br />
width = 1000 # choose a radius for the cropped image</p>
<p>crop = a[center[0]-width:center[0]+width,center[1]-width:center[1]+width]<br />
# imshow(crop)</p>
<p>stack = zeros((2000,10)) # create an array to save the slices<br />
total = stack[:,0] # create an array to save the average slice</p>
<p>for i in range(10): # take ten slices<br />
	stack[:,i] = rotate(crop,i*36,reshape=False)[1000,:]<br />
	total += stack[:,i]</p>
<p>plot(total) # plot the data<br />
savetxt(&quot;Jefferson-v2.dat&quot;, total) # save the data to a file<br />
[/sourcecode]</p>
<p>[caption id="attachment_431" align="alignleft" width="200" caption="Kirlian Photograph of a US Dime"]<a href="http://dawes.files.wordpress.com/2011/01/jefferson.jpg"><img class="size-medium wp-image-431" title="Corona Image of Dime" src="{{ site.baseurl }}/assets/jefferson.jpg?w=200" alt="Dime Corona" width="200" height="300" /></a>[/caption]</p>
<p>This example isn't as obvious but it was a great example of how easy it can be to code something to do a quick data analysis. I had a student working on Kirlian Photography (I'll save that discussion for a later post) by imaging the corona around electrified objects. In this case, the object was a dime and we wanted to know how the corona brightness depended on distance from the edge of the dime.</p>
<p>[caption id="attachment_432" align="alignright" width="150" caption="The corona intensity as a function of radius. The data is the average of 36 radial cross-sections through the center of the image."]<a href="http://dawes.files.wordpress.com/2011/01/screen-shot-2011-01-02-at-9-40-52-am.png"><img class="size-thumbnail wp-image-432" title="Corona Radius Plot" src="{{ site.baseurl }}/assets/screen-shot-2011-01-02-at-9-40-52-am.png?w=150" alt="Corona Radius" width="150" height="110" /></a>[/caption]</p>
<p>We wanted to model the effect so we needed something to compare to our models. Python imports the image using the imread function. Then we assign a center and crop the image to make it square. Finally, to build up a bunch of cross sections, we start taking slices and then rotating the image and take another slice. The slices are then averaged to give a nice smooth curve describing the corona brightness as a function of radius.</p>
<h3></h3>
<h3>Propagate errors (uncertainty)</h3>
<p>[sourcecode language="python"]<br />
from uncertainties import ufloat<br />
from uncertainties.umath import *</p>
<p># Calculate number of photons per pulse<br />
#      P * tau<br />
# N = ---------<br />
#         E<br />
#<br />
# Where P -&gt; power, tau -&gt; pulse duration, E -&gt; photon energy</p>
<p>tau = ufloat(&quot;3.2e-6+/-0.2e-6&quot;)<br />
# in seconds<br />
wavelambda = ufloat(&quot;780+/-0.25&quot;)<br />
# in nanometers (note, &quot;lambda&quot; is a special word in python)<br />
P = ufloat(&quot;3.2e-9+/-0.5e-9&quot;)<br />
# in watts</p>
<p># photon energy is hc/lambda, hc = 1240 eV*nm or 1.986e-16 J*nm</p>
<p>N = (P * tau)/(1.986e-16/wavelambda)</p>
<p>print N<br />
[/sourcecode]</p>
<p>This example is fairly straightforward. The uncertainty package has several ways to specify a number and the error. I like the +/- text way since it is easy to read. Calculations simply "do the right thing" when you define the numbers as ufloat (floats with associated uncertainty).</p>
